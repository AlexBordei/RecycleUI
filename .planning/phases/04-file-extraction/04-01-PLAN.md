---
phase: 04-file-extraction
plan: 01
type: execute
wave: 1
depends_on: ["03-02"]
files_modified: [app/Services/FileExtractorService.php, app/Filament/Pages/Upload.php, tests/Feature/FileExtractorTest.php]
autonomous: false
---

<objective>
Create FileExtractorService to move validated zip contents to user's Processing folder and integrate with upload flow.

Purpose: Complete the upload-to-extraction pipeline so valid zips land in the correct user directory.
Output: Working extraction with proper path handling, cleanup on failure, and user feedback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-zip-validation/03-02-SUMMARY.md
@app/Services/ZipValidatorService.php
@app/Services/UserPathService.php
@app/Filament/Pages/Upload.php
@config/filesystems.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileExtractorService</name>
  <files>app/Services/FileExtractorService.php</files>
  <action>
    Create a service that moves validated content from temp to user's Processing directory:

    1. Create `app/Services/FileExtractorService.php`:
       ```php
       <?php

       namespace App\Services;

       use App\Models\User;
       use Carbon\Carbon;
       use Illuminate\Support\Facades\File;

       class FileExtractorService
       {
           protected UserPathService $pathService;

           /**
            * The destination path where files were extracted.
            */
           protected ?string $destinationPath = null;

           /**
            * The timestamp used for the extraction path.
            */
           protected ?Carbon $timestamp = null;

           public function __construct(?UserPathService $pathService = null)
           {
               $this->pathService = $pathService ?? new UserPathService();
           }

           /**
            * Extract validated content from temp path to user's Processing directory.
            *
            * @param string $tempPath The temporary extraction path from ZipValidatorService
            * @param User $user The user performing the upload
            * @param Carbon|null $timestamp The timestamp for the directory (defaults to now)
            * @return array{success: bool, path: string, folders: int, message: string}
            */
           public function extractToProcessing(string $tempPath, User $user, ?Carbon $timestamp = null): array
           {
               $this->timestamp = $timestamp ?? Carbon::now();

               // Get/create the user's processing directory
               $this->destinationPath = $this->pathService->ensureProcessingDirectoryExists($user, $this->timestamp);

               // Count folders being moved
               $folders = File::directories($tempPath);
               $folderCount = count($folders);

               if ($folderCount === 0) {
                   return [
                       'success' => false,
                       'path' => $this->destinationPath,
                       'folders' => 0,
                       'message' => 'No folders found in archive to extract.',
                   ];
               }

               try {
                   // Move each folder from temp to destination
                   foreach ($folders as $folder) {
                       $folderName = basename($folder);
                       $targetPath = $this->destinationPath . '/' . $folderName;

                       // If target exists, remove it first (shouldn't happen but safety)
                       if (File::isDirectory($targetPath)) {
                           File::deleteDirectory($targetPath);
                       }

                       // Move the folder
                       File::moveDirectory($folder, $targetPath);
                   }

                   return [
                       'success' => true,
                       'path' => $this->destinationPath,
                       'folders' => $folderCount,
                       'message' => "Successfully extracted {$folderCount} folder(s) to Processing.",
                   ];
               } catch (\Exception $e) {
                   // Cleanup on failure
                   $this->cleanup();

                   return [
                       'success' => false,
                       'path' => $this->destinationPath,
                       'folders' => 0,
                       'message' => 'Extraction failed: ' . $e->getMessage(),
                   ];
               }
           }

           /**
            * Clean up the destination directory on failure.
            */
           public function cleanup(): void
           {
               if ($this->destinationPath && File::isDirectory($this->destinationPath)) {
                   // Only delete if empty or we created it
                   $contents = File::allFiles($this->destinationPath);
                   if (empty($contents)) {
                       File::deleteDirectory($this->destinationPath);
                   }
               }
               $this->destinationPath = null;
           }

           /**
            * Get the destination path.
            */
           public function getDestinationPath(): ?string
           {
               return $this->destinationPath;
           }

           /**
            * Get the timestamp used.
            */
           public function getTimestamp(): ?Carbon
           {
               return $this->timestamp;
           }

           /**
            * Get user-friendly relative path (for display).
            */
           public function getRelativePath(User $user): string
           {
               if (!$this->timestamp) {
                   return '';
               }
               return $this->pathService->generateUserPath($user, $this->timestamp);
           }
       }
       ```

    2. Key features:
       - Uses UserPathService for consistent path generation
       - Moves folders (not copies) for efficiency
       - Returns structured result with success/failure, path, folder count
       - Cleanup on failure removes empty destination directory
       - Handles special characters via UserPathService (already preserves spaces)

    Requirements covered:
    - EXTR-01: Extracts to Processing path using UserPathService
    - EXTR-02: Handles special characters (delegated to UserPathService)
  </action>
  <verify>
    1. Service class exists at app/Services/FileExtractorService.php
    2. Has extractToProcessing() method returning structured result
    3. Uses UserPathService for path generation
    4. Has cleanup() method for failure cases
  </verify>
  <done>
    - FileExtractorService created with extraction and cleanup
    - Uses existing UserPathService for path handling
    - Returns structured result for UI feedback
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate extraction into Upload page submit flow</name>
  <files>app/Filament/Pages/Upload.php, resources/views/filament/pages/upload.blade.php</files>
  <action>
    Update submit() to extract after validation passes:

    1. In Upload.php, add new properties and update submit():
       ```php
       use App\Services\FileExtractorService;

       /**
        * Extraction result after successful validation.
        */
       public ?array $extractionResult = null;

       /**
        * Submit the archive for processing.
        */
       public function submit(): void
       {
           $this->validate();
           $this->validating = true;
           $this->validationResult = null;
           $this->extractionResult = null;

           try {
               $validator = new ZipValidatorService();
               $this->validationResult = $validator->extractAndValidate($this->archive);

               if ($this->validationResult['valid']) {
                   // Validation passed - now extract to Processing folder
                   $extractor = new FileExtractorService();
                   $this->extractionResult = $extractor->extractToProcessing(
                       $validator->getTempPath(),
                       auth()->user()
                   );

                   if ($this->extractionResult['success']) {
                       Notification::make()
                           ->title('Upload Complete')
                           ->body($this->extractionResult['message'])
                           ->success()
                           ->send();

                       // Clear the form for next upload
                       $this->archive = null;
                       $this->preview = [];
                   } else {
                       Notification::make()
                           ->title('Extraction Failed')
                           ->body($this->extractionResult['message'])
                           ->danger()
                           ->send();
                   }
               } else {
                   // Invalid zip - show errors (no extraction)
                   $errorCount = array_sum(array_map('count', $this->validationResult['errors']));
                   Notification::make()
                       ->title('Validation Failed')
                       ->body("Found {$errorCount} issue(s) in " . count($this->validationResult['errors']) . ' folder(s). See details below.')
                       ->danger()
                       ->send();
               }
           } catch (\Exception $e) {
               Notification::make()
                   ->title('Processing Error')
                   ->body('Failed to process archive: ' . $e->getMessage())
                   ->danger()
                   ->send();
           }

           $this->validating = false;
       }
       ```

    2. Update removeFile() to clear extraction result:
       ```php
       public function removeFile(): void
       {
           $this->archive = null;
           $this->preview = [];
           $this->validationResult = null;
           $this->extractionResult = null;
           $this->resetValidation('archive');
       }
       ```

    3. In upload.blade.php, add extraction success display after validation results:
       ```blade
       {{-- Extraction success display --}}
       @if($extractionResult && $extractionResult['success'])
           <div class="mt-4 p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg">
               <div class="flex items-start">
                   <x-heroicon-o-check-circle class="w-6 h-6 text-green-500 mr-3 flex-shrink-0" />
                   <div>
                       <h3 class="text-sm font-medium text-green-800 dark:text-green-200">
                           Upload Complete
                       </h3>
                       <p class="mt-1 text-sm text-green-700 dark:text-green-300">
                           {{ $extractionResult['message'] }}
                       </p>
                       <p class="mt-2 text-xs text-green-600 dark:text-green-400 font-mono break-all">
                           {{ $extractionResult['path'] }}
                       </p>
                   </div>
               </div>
           </div>
       @endif
       ```

    4. Update the flow so form clears on successful extraction but preserves on validation failure.
  </action>
  <verify>
    1. Submit flow: validate -> if valid, extract -> show result
    2. Successful extraction shows path and clears form
    3. Failed validation shows errors, no extraction attempted
    4. Failed extraction shows error message
  </verify>
  <done>
    - Extraction integrated into submit flow
    - Success displays path where files were extracted
    - Form clears after successful extraction
    - Errors handled at each stage
  </done>
</task>

<task type="auto">
  <name>Task 3: Write tests for FileExtractorService</name>
  <files>tests/Feature/FileExtractorTest.php</files>
  <action>
    Create comprehensive tests for the extraction service:

    1. Create `tests/Feature/FileExtractorTest.php`:
       ```php
       <?php

       namespace Tests\Feature;

       use App\Models\User;
       use App\Services\FileExtractorService;
       use App\Services\UserPathService;
       use Carbon\Carbon;
       use Illuminate\Support\Facades\File;
       use Illuminate\Support\Facades\Storage;
       use Tests\TestCase;

       class FileExtractorTest extends TestCase
       {
           protected FileExtractorService $extractor;
           protected string $testTempPath;
           protected ?User $testUser = null;

           protected function setUp(): void
           {
               parent::setUp();

               $this->extractor = new FileExtractorService();
               $this->testTempPath = storage_path('app/test-temp/' . uniqid('test_'));
               File::makeDirectory($this->testTempPath, 0755, true);

               // Create test user
               $this->testUser = User::factory()->create([
                   'full_name' => 'Test User',
               ]);
           }

           protected function tearDown(): void
           {
               // Clean up test temp directory
               if (File::isDirectory($this->testTempPath)) {
                   File::deleteDirectory($this->testTempPath);
               }

               // Clean up any processing directories created
               $processingPath = Storage::disk('processing')->path($this->testUser->full_name);
               if (File::isDirectory($processingPath)) {
                   File::deleteDirectory($processingPath);
               }

               parent::tearDown();
           }

           /**
            * Create test folder structure in temp path.
            */
           protected function createTestFolders(array $folderNames): void
           {
               foreach ($folderNames as $name) {
                   $folderPath = $this->testTempPath . '/' . $name;
                   File::makeDirectory($folderPath, 0755, true);
                   // Add a test file to each folder
                   File::put($folderPath . '/test.txt', 'test content');
               }
           }

           #[\PHPUnit\Framework\Attributes\Test]
           public function it_extracts_folders_to_processing_directory()
           {
               $this->createTestFolders(['Transport001', 'Transport002']);
               $timestamp = Carbon::create(2026, 1, 21, 10, 30);

               $result = $this->extractor->extractToProcessing(
                   $this->testTempPath,
                   $this->testUser,
                   $timestamp
               );

               $this->assertTrue($result['success']);
               $this->assertEquals(2, $result['folders']);
               $this->assertStringContainsString('Test User', $result['path']);
               $this->assertStringContainsString('21-01-2026 10:30', $result['path']);

               // Verify folders exist in destination
               $this->assertTrue(File::isDirectory($result['path'] . '/Transport001'));
               $this->assertTrue(File::isDirectory($result['path'] . '/Transport002'));
           }

           #[\PHPUnit\Framework\Attributes\Test]
           public function it_handles_user_names_with_spaces()
           {
               $user = User::factory()->create([
                   'full_name' => 'ALEXANDRU-IONEL BORDEI',
               ]);

               $this->createTestFolders(['Folder1']);
               $timestamp = Carbon::create(2026, 1, 21, 14, 45);

               $result = $this->extractor->extractToProcessing(
                   $this->testTempPath,
                   $user,
                   $timestamp
               );

               $this->assertTrue($result['success']);
               $this->assertStringContainsString('ALEXANDRU-IONEL BORDEI', $result['path']);

               // Clean up
               File::deleteDirectory(Storage::disk('processing')->path('ALEXANDRU-IONEL BORDEI'));
           }

           #[\PHPUnit\Framework\Attributes\Test]
           public function it_handles_user_names_with_special_characters()
           {
               $user = User::factory()->create([
                   'full_name' => 'Ion Păun-Țepeș',
               ]);

               $this->createTestFolders(['Folder1']);

               $result = $this->extractor->extractToProcessing(
                   $this->testTempPath,
                   $user
               );

               $this->assertTrue($result['success']);
               $this->assertStringContainsString('Ion Păun-Țepeș', $result['path']);

               // Clean up
               File::deleteDirectory(Storage::disk('processing')->path('Ion Păun-Țepeș'));
           }

           #[\PHPUnit\Framework\Attributes\Test]
           public function it_returns_failure_for_empty_temp_directory()
           {
               // Empty temp directory (no folders)
               $result = $this->extractor->extractToProcessing(
                   $this->testTempPath,
                   $this->testUser
               );

               $this->assertFalse($result['success']);
               $this->assertEquals(0, $result['folders']);
               $this->assertStringContainsString('No folders found', $result['message']);
           }

           #[\PHPUnit\Framework\Attributes\Test]
           public function it_provides_correct_folder_count()
           {
               $this->createTestFolders(['A', 'B', 'C', 'D', 'E']);

               $result = $this->extractor->extractToProcessing(
                   $this->testTempPath,
                   $this->testUser
               );

               $this->assertTrue($result['success']);
               $this->assertEquals(5, $result['folders']);
           }

           #[\PHPUnit\Framework\Attributes\Test]
           public function it_returns_relative_path_for_display()
           {
               $this->createTestFolders(['Folder1']);
               $timestamp = Carbon::create(2026, 1, 21, 10, 30);

               $this->extractor->extractToProcessing(
                   $this->testTempPath,
                   $this->testUser,
                   $timestamp
               );

               $relativePath = $this->extractor->getRelativePath($this->testUser);

               $this->assertEquals('Test User/21-01-2026 10:30', $relativePath);
           }

           #[\PHPUnit\Framework\Attributes\Test]
           public function it_moves_folders_not_copies()
           {
               $this->createTestFolders(['MoveTest']);

               $result = $this->extractor->extractToProcessing(
                   $this->testTempPath,
                   $this->testUser
               );

               $this->assertTrue($result['success']);

               // Source folder should no longer exist
               $this->assertFalse(File::isDirectory($this->testTempPath . '/MoveTest'));

               // Destination should exist
               $this->assertTrue(File::isDirectory($result['path'] . '/MoveTest'));
           }
       }
       ```

    2. Run tests: `php artisan test --filter=FileExtractorTest`
  </action>
  <verify>
    1. All tests pass: `php artisan test --filter=FileExtractorTest`
    2. Tests cover: extraction, special characters, empty directory, folder count, move (not copy)
  </verify>
  <done>
    - Comprehensive test suite for FileExtractorService
    - Special character handling tested
    - All tests pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete file extraction pipeline - validated zips extract to user's Processing folder</what-built>
  <how-to-verify>
    **Prerequisites:**
    - Database configured and migrated
    - Admin user seeded with full_name set (e.g., "Admin User")
    - SIATD_PROCESSING_PATH configured in .env OR using default storage path
    - Valid test zip with all 9 required files per folder

    **Check .env configuration:**
    ```bash
    # Option A: Use Desktop path (matches spec)
    SIATD_PROCESSING_PATH=/Users/YOUR_USERNAME/Desktop/SIATD/Processing

    # Option B: Use default (storage/app/siatd/processing)
    # Just leave SIATD_PROCESSING_PATH unset
    ```

    **Test flow:**
    1. Start server: `php artisan serve`
    2. Visit: http://localhost:8000/admin
    3. Login with: admin / password
    4. Click "Upload Archive" in navigation

    **Test EXTR-01 (Extract to Processing path):**
    - Upload a valid zip (all 9 files per folder)
    - Click "Validate and Process"
    - Validation passes, extraction runs
    - Success message shows with path
    - Check the path - folders should exist there

    **Verify extraction path format:**
    - Path should be: `[Processing Root]/[User Full Name]/[DD-MM-YYYY HH:mm]/[folders...]`
    - Example: `~/Desktop/SIATD/Processing/Admin User/21-01-2026 14:30/Transport001/`

    **Test EXTR-02 (Special characters in name):**
    - Create user with special name (e.g., "Ion Păun-Țepeș" or "ALEXANDRU-IONEL BORDEI")
    - Login as that user
    - Upload and extract
    - Path should contain the full name with spaces/special chars

    **Test form reset:**
    - After successful extraction, form should be cleared
    - Ready for next upload

    **Test validation failure (no extraction):**
    - Upload invalid zip (missing files)
    - Validation fails with errors
    - NO extraction attempted
    - Files NOT in Processing folder
  </how-to-verify>
  <resume-signal>Type "approved" if extraction works correctly to Processing path, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] FileExtractorService exists and works
- [ ] Uses UserPathService for path generation
- [ ] Handles special characters in user names
- [ ] Integration with Upload page submit flow complete
- [ ] Successful extraction shows path and clears form
- [ ] Failed validation doesn't extract
- [ ] All tests pass
- [ ] Human verification checkpoint passed
</verification>

<success_criteria>
- EXTR-01: Extracts to `~/Desktop/SIATD/Processing/[User Full Name]/[DD-MM-YYYY HH:mm]/`
- EXTR-02: Handles spaces and special characters in user full names
- Form clears after successful extraction
- Validation failure prevents extraction
- User sees extraction path on success
</success_criteria>

<output>
After completion, create `.planning/phases/04-file-extraction/04-01-SUMMARY.md`
</output>
